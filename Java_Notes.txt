Link : https://github.com/imranxc/java-basics-to-advanced/tree/master/notebooksObject has 2 things:1.Properties2.Behaviourinterface and abstract class in detail notes :Overridding is not possible for variables...class Main{     public static void main(String [] args){        A a=new A();        System.out.println(a.x);        a.greet();        B b=new B();        System.out.println(b.x);        b.greet();        A c=new B();        System.out.println(c.x);        c.greet();    } }class A {    int x=555;    void greet() {        System.out.println("Parent, ");    }}class B extends A {    int x=666;    void greet() {        System.out.println("Child, ");    }}Static methods are resolved at compile-time, not runtime.Questions :1. What happens if a constructor is declared private ?2. What happens when a class is declared private ?3. Nested classes ? - https://www.geeksforgeeks.org/java/nested-classes-java/4. String is immutable but we store the values like    String s1=new String("Hello");    s1 ="hi";  How?  because here s1 is storing the reference of the object the entire string . if u check how string is written final char[] ; the value cannot be changed , but the variable can refer to different object .5. Can we call a static method from a non-static ? (vice-versa)6.Would you like examples of how private constructors are used in real-world libraries like Collections, Math, or Enum?7.Constructors are not allowed in interfaces because constructors can not be inherited and overridden.8.there is no default constructor in abstract class . if we want we can write one.9. Enum - normal , custom value, overriding, abstract method , Enum can implement interface , constants are static and final, constructors are private , no class can inherit Enum class because Enum extends(inherits) java.lang.Enum which is a final class (java language specification used by compiler)10. Generic class - WildCards :Case 1: List<? extends T> → CANNOT addWhy?? extends Number could be Integer, Double, Float, etc.The actual type is unknown, only guaranteed to be some subtype of Number.So adding 10 (an Integer) might be wrong if the actual list was List<Double>.❌ Therefore, not safe to add anything (except null).2. Case 2: List<?> → CANNOT addWhy?? means "unknown type" — could be String, Integer, Object, anything.So the compiler doesn’t know the type → adding "hello" might be wrong.❌ Again, not safe to add anything (except null).3. Case 3: List<? super T> → CAN add TWhy is this safe?The list is guaranteed to accept Integer or anything above it (like Number, Object).Since Integer is a valid subtype of all those, it’s safe to add.✅ Key point:You can always safely insert T into a list declared as <? super T>, because its actual type is guaranteed to be a supertype of T.For <? super Integer>:Compiler knows: List can be of Integer, Number, or Object → All can hold Integer → ✅ Safe to addFor <? extends Number>:Compiler knows: List can be of Integer, Double, etc → But can't guarantee the exact type → ❌ Unsafe to addWhat is PECS?PECS helps you decide which wildcard to use:Use ? extends T when a collection produces values (you only read from it)Use ? super T when a collection consumes values (you only write into it)===================================================================================================================================| Type              | Syntax                                | Purpose                      || ----------------- | ------------------------------------- | ---------------------------- || Generic Class     | `class Box<T> {}`                     | Store/type-safe container    || Generic Method    | `<T> void print(T x)`                 | Reusable logic with any type || Generic Interface | `interface My<T>`                     | Define generic contracts     || Bounded Types     | `<T extends Number>`                  | Limit accepted types         || Wildcards         | `<?>`, `<? extends T>`, `<? super T>` | Read/write flexibility       |1. Abstract Classes▶ What is an Abstract Class?A class that is declared using the abstract keyword and may contain abstract methods (without implementation) and concrete methods (with implementation).▶ Key RulesCannot be instantiated.Can have constructors.Can have any access modifier: private, protected, default, public.Can have final, static, and instance variables.Can extend a class and can be extended by another abstract or concrete class.▶ Rare ConceptsAbstract class can implement an interface and need not provide method definitions (let subclasses do it).You can override concrete methods in the subclass.2. Interfaces▶ What is an Interface?An interface is a contract: any class that implements it must provide implementations for its methods (unless it's abstract).▶ Key RulesCannot have constructors.All methods are implicitly public and abstract (before Java 8).From Java 8: default and static methods allowed.From Java 9: private methods allowed.Fields must be public static final (constants).Cannot have instance variables.Can extend multiple interfaces.▶ Rare ConceptsCan be used to achieve multiple inheritance.Can contain default methods with body.Can contain static and private static methods.Abstract Class vs Interface - Comparison TableFeature                          | Abstract Class                                   | Interface---Keyword                          | abstract class                                   | interfaceInheritance Type                 | Single inheritance                               | Multiple inheritanceConstructors                     | Allowed                                          | Not allowedMethod Types                     | Abstract + Concrete                              | Abstract (Java 7), default/static (Java 8+), private (Java 9+)Access Modifiers for Methods     | public, protected, private, default              | Mostly public, private from Java 9Variables                        | Instance variables allowed                       | Only public static final (constants)Static Methods                   | Allowed                                          | Allowed (since Java 8)Final Methods                    | Allowed                                          | Not allowedFields/Attributes                | Can be any type and any modifier                 | Must be public static finalMultiple Inheritance             | Not supported                                    | Supported via multiple interfacesImplements/Extends               | Can extend class or abstract class               | Can extend one or more interfacesInstantiation                    | Cannot be instantiated                           | Cannot be instantiatedDefault Methods                  | Concrete methods defined normally                | Allowed from Java 8Private Methods                  | Allowed                                          | Allowed from Java 9Static Blocks                    | Allowed                                          | Not allowedUse Case                         | Partial abstraction, shared code                 | 100% abstraction, defining capabilitiesPerformance                      | Slightly faster                                  | Slightly slower due to indirectionBackward Compatibility           | Stable in earlier Java versions                 | Evolved significantly in Java 8 and 9Lambda Functions :A lambda function is an anonymous method (no name) that you can pass as a value.Syntax:(parameters) -> { body }or short:param -> expressionless code , no much boiler plate , more readableHow to Use Lambda Functions in Java?Lambda functions are used where a functional interface is expected.Functional Interface = Interface with only ONE abstract methodJava provides built-in ones like:RunnableComparablePredicate<T> - Takes a value T and returns a boolean resultFunction<T, R> - Takes input of type T, returns result of type RConsumer<T> - Takes a value T, performs some action, returns nothingSupplier<T> - Takes no input, returns a value of type TCollection :It represents the group of objects. It's an interface which provides methods to work on group of objects.Common methods-size() - return number of elements presentisEmpty() - (Output Boolean) check collection is empty or notcontains() - search element in the collection , return BooleantoArray() - converts collection into an Arrayadd() - Used to insert an element into the collectionremove() -  used to remove the element from the collectionaddAll() - used to add an entire collection into another collectionremoveAll() - Remove all the elements from the collection , which are present in the collection passe in the parameter.clear() - Remove all the elements from the collection .equals() - used to check if the 2 collections are equal or not.stream() and parallelStream() - provide efficient way to work with collection like filtering, processing data etc.iterator() - used to iterate the collectionIterable: used to traverse the collection.Methods :1.iterator() -it provides iterator object as result.Methods -hasNext() - return true, if there is more elements in the collectionnext() - Return the next element in the iteratorremove() - Remove the last elememt returned by iterator.2. forEach() - iterator collection using Lambda expression. Lambda expression is called for each elements from the collection.Collection vs Collections1. Collection is part of java collection Framework. And its an interface , which expose various methods implemented by various collection classes like ArrayList,stack,LinkedList etc...2.collections is a Utility class and provide static methods, which are used to operate on collection like swapping , searching , reverse , sorting, copy , etc...Method :(Collections.)sort - Collections.sort()binarySearch - Collections.binarySearch()getreverseshuffleswapcopymin - Collections.min()max - Collections.max()rotateunmodifiableCollectionCollection :ArrayList :Non-synchronized: Not thread-safe by default (use Collections.synchronizedList() for thread safety).Maintains the insertion order of elements.     Non-synchronizedArrayList is implemented as a resizable array.     The array is created with an initial capacity (default is 10).     newCapacity = oldCapacity + (oldCapacity >> 1)     Collections.synchronizedList(new ArrayList<>()) and new CopyOnWriteArrayList<>() - to create a synchronized ArrayList2. List :List is an interface, it cannot be instantiated directly; instead, classes like ArrayList, LinkedList, and Vector implement it.      Maintains insertion order.      Allows duplicate elements.      Non-synchronized      Supports index-based access (elements can be accessed, added, or removed using their index).      Provides methods for searching, iteration, and manipulation of elements.      It's capacity and implementation depends on the collection which is implementing it.      Common Implementations:           ArrayList: Backed by a dynamic array, best for random access and iteration.           LinkedList: Backed by a doubly-linked list, best for frequent insertions/deletions.           Vector: Similar to ArrayList but synchronized (thread-safe) and considered legacy.           CopyOnWriteArrayList: A thread-safe variant of ArrayList for concurrent access.   3. LinkedList :      It uses doubly linkedlist      it is a node with the reference of prev and next nodes      LinkedList has no predefined capacity. It grows as nodes are added, limited only by available memory.      LinkedList implements the List, Deque, and Queue interfaces      LinkedList is not thread-safe by default.Collections.synchronizedList(new LinkedList<>()) , CopyOnWriteArrayList,      Use explicit synchronization with synchronized blocks. - thread- safe      no default capacity because it is stored nodes that are dynamically allocated memory.4. HashMap :      **Map- is a interface . Types of map  : HashMap , TreeMap , LinkedHashMap**      HashMap uses a hash table to store key-value pairs, which consists of an array of buckets      Initial Capacity: Default is **16** buckets. Can be specified in the constructor (e.g., new HashMap<>(32)).      not-ordered      one null key and multiple null values.      Not thread-safe      Thread Safety: Use ConcurrentHashMap      Use HashMap for general-purpose key-value storage with fast lookups and no need for order or thread safety.      Use LinkedHashMap when insertion or access order is needed.      Use TreeMap when keys need to be sorted.      Use ConcurrentHashMap for thread-safe operations in concurrent applications.---      for (Map.Entry<String, Integer> entry : map.entrySet()) {            System.out.println(entry.getKey() + ": " + entry.getValue());        }---      System.out.println("Using keySet:");        for (String key : map.keySet()) {            System.out.println(key + ": " + map.get(key));        }---        // Iterate using forEach        System.out.println("Using forEach:");        map.forEach((key, value) -> System.out.println(key + ": " + value));---5. Hashset :Set is a interface. Types of set : HashSet , LinkedHashSet ,TreeSet.    not ordered    unique elements only.    Allows null    Not thread-safe (use Collections.synchronizedSet() for thread-safety).    HashSet uses a HashMap to store elements.    When you add an element e, it is stored as a key in the HashMap, with a dummy value (PRESENT object).    Default initial capacity = 166. StackLIFO (Last In First Out): Push to the top, pop from the top.Java’s Stack is a class that extends Vector (an older synchronized dynamic array).It's synchronized by default, which means it's thread-safe but slower than other options like Deque.Stack inherits from Vector.Internally it uses a resizable array.Whenever capacity is exceeded, a new array is created with increased size (usually doubled).Initial capacity is 10 (inherited from Vector).| Method             | Description                                     || ------------------ | ----------------------------------------------- || `push(E item)`     | Adds (pushes) an item onto the top of the stack || `pop()`            | Removes and returns the item from the top       || `peek()`           | Returns the item at the top (without removing)  || `empty()`          | Checks if the stack is empty                    || `search(Object o)` | Returns the 1-based position from the top or -1 || `size()`           | Returns number of elements                      |Comparator vs ComparableBoth provides a way to sort the collection of objects.Comparator -Arrays.sort() o1 > o2 =1o1 == o2 =0o1 < o2 = -1compute method in hashmap and other methods which are different in arraylist, linkedlist,set,comparator, comparableStreams :Consider it is a pipeline. steps 1: Create a streamStep 2:  one or more intermediate operation.(Filter,map,etc....) it is a lazy one, it starts only when terminal operation triggers itStep 3: Terminal operation (count,reduce,etc.)- it triggers the intermediate operationHow to create stream : there are 5 methods , 1. Stream.of() ->creating from static methode String<String> str=Stream.of("sanjai","hi") 2. creating using Builder Stream.Builder<Integer> num=Stream.builder();     num.add(100).add(200);     Stream<Integer> snum=num.build(); 3. From iterate() -> Stream.iterate() 4. From collection ._collection name_.stream() 5. From arrays . Arrays.stream(_array name__)Intermediate operation : 1. filter() -> filters according to the condition 2. map() -> tranforms the data to another form 3. flatMap() -> it is used to make the list of list to a single list. 4. distinct() -> it is used to remove duplicates 5. sorted() -> it is used to sort  6. peek() -> 	helps to see the intermediate results of the stream	 7. limit() -> limits the function 8. skip() -> skips the first n elements 9. mapToInt() -> helps to work with primitive int (IntStream ) 10. mapToLong() ->helps to work with primitive long (LongStream) 11. mapToDouble() -> helps to work with primitive double (DoubleStream)Why we call intermediate operations as Lazy ?Stream<Integer> streamlist=number.stream().filter((Integer val) -> val>3).peek((Integer val) ->System.out.println(val));this won't run until terminal operation is called so only lazy.if we give streamlist.count() -> it will print numbers greater than 3.Sequence of stream operations :Some operation need complete stream to work like sorted(). but filter and map or not like that just passing one value is enough to work with sequentially.Terminal Operations : 1. forEach() -> perform action on each element of the stream 2. toArray() -> it will collect the elements of stream into array 3. reduce() -> does reduction on the stream elements. perform some aggregation functions like addition,etc.. 4. collect() -> it is used to collect the stream element into list, set , map...( Collections.toList() ) 5. .min() and .max() -> it used to find the maximum or minimum number from the stream based on comparator provided. .min((Integer val1,Integer val2 ) -> val2-val1) 6. count() -> count the number of elements present in the stream 7. anyMatch() -> return Boolean if any value in the stream matches predicate. 8. allMatch() -> check if all value in the stream matches the predicate and return Boolean 9. noneMatch() -> check if no value in the stream matches the predicate and return Boolean 10. findFirst() -> find the first element of the stream 11. findAny() -> find any random elements of the streamHow many times we can use a single stream : one terminal operation is used on a stream , it is closed/consumed and cannot be used again for another terminal operation. one stream only on terminal operation .File Handling :2 types : Byte stream - InputStream , OutputStream ,FileInputStream , FileOutputStream  Character Stream - Reader , Writer, FileReader , FileWriter  File :Methods --------createNewFile(): Creates a new, empty file if it doesn’t exist. Returns true if successful.delete(): Deletes the file or directory. Returns true if successful.exists(): Checks if the file or directory exists.isFile(): Returns true if the path represents a file.isDirectory(): Returns true if the path represents a directory.listFiles(): Returns an array of File objects for files in a directory.mkdir(): Creates a directory.length(): Returns the size of the file in bytes.getAbsolutePath(): Returns the absolute path of the file.renameTo(File dest): Renames the file to the specified destination.Byte Streams :  FileInputStream - to read bytes from file [direct access from disk ] Methods ------------   read(): Reads a single byte (returns -1 at end-of-file).   read(byte[]): Reads bytes into an array.   available(): Returns the number of bytes available to read.   close(): Closes the stream. FileOutputStream - to write to a file [direct write to disk] Methods--------------------    write(int): Writes a single byte.    write(byte[]): Writes an array of bytes.    flush(): Flushes buffered data to the file.    close(): Closes the stream.    String data = "hello world";    fos.write(data.getBytes()); ---.getBytes() convert to bytes while writing bcz it stores as raw data in disk BufferedInputStream - reduce direct access from file [disk -> buffer ,then gives from buffer ] (it wraps around FileInputStream ) Methods ------------------ Maintains an internal byte array buffer.   read()   BufferedInputStream bis = new BufferedInputStream(new FileInputStream("buffered.txt")))----------------------------------------------------------------------------------------------------------------------------------BufferedOutputStream - reduce direct write to file[ Buffer → then flushed to file (improves performance)] (it wraps around FileOutputStream ) Methods--------------Stores written bytes into its internal buffer.   write()   flush() BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("buffered.txt"))Character Stream :   FileReader - reads characters from file     Methods -----      	read(): Reads a single character (returns -1 at end-of-file).        read(char[]): Reads characters into an array.        close(): Closes the reader.   FileWriter - writes characters to file      Methods --------           write(int): Writes a single character.           write(String): Writes a string.           flush(): Flushes buffered data.           close(): Closes the writer.   InputStreamReader - ready() , read()   OutputStreamWriter -        Buffered Readers/Writers      Buffered character streams (BufferedReader, BufferedWriter) improve performance by reducing direct file access.      it wraps around FileReader , FileWriter , InputStreamReader , OutputStreamWriter . Key Methods for BufferedReader:  readLine(): Reads a line of text.  read(): Reads a single character or array of characters. Key Methods for BufferedWriter:   write(String): Writes a string.   newLine(): Writes a platform-specific line separator.   flush(): Flushes buffered data.------------------------------------------------------------------------------------------------------------------------------------------SQLite db:  DDL - create , drop , alter , truncate   DML - insert , update , delete   DQL - select sqlite3.databases.tablespragma foreign_keys=ON ----> to turn on foreign key relationSet:union - combine [takes all from both (if 2 are there excludes 1)]intersect - [gives which is only common]except - [gives everything except common]  --------The EXCEPT operator in SQL returns the rows from the first query that do not exist in the second query.Think of it like "Query1 MINUS Query2" – it filters out common rows and keeps only the unique ones from the first query.in - use in when u get multiple values as result from subquery= - use when u get single value as result form subquerygroup by - if u are using group by the column using in group by should appear in select also,[select city from students group by city]having - use after group by-----------------------------------------------------------------------------------------------------------                                          JDBC       Java Program                                               Driver ResultSet Statement Connection -------------------------   Database program                  |                                                   |                  |                                                   |                  SQL                                               Storage                                                                        Driver :2 tasksby using driver we establish connection between database program and java programdata types used in java is different from data types used in DB.conversion is done by driver (java to db types and db to java type)java.sql :Java provides class for connection present in java.sql class.by using this we create a sql statementquery is sent via connection to DB it executes and result is return , driver converts to java comfortable form . Result is obtained under result set.Types of Drivers : Type-1 -> JDBC=OBDC Bridge(partial) Type-2 Native-API (partial) Type-3 Java-Net Protocol Driver(pure) Type-4 Thin Driver (pure)Type - 1To connect to each DB a separate Driver is needed to overcome that problem Microsoft introduced ODBC.Java provides driver to connect to ODBC that is called JDBC-OBDC Bridge.ODBC - by Microsoft it a neutral driver with the help of this it can connect with any database.one side java - one side native so only partialType - 2 driver for sqlite oracle uses c. uses OCI. java is used to communicate with OCI so it is partial.Type - 3 there is a server between oracle db and java program. java treat the server itself as DB so it uses java to communicate to server. and does not bother about which language is used by server to communicate to db. so Pure.Type -4  driver is direct so directly it can communicate with DB. it is purely written in java and so it is pure.Steps to connect to DB :  1. Use Driver 2. Establish connection 3. Create statement 4.Execute query 5. Get ResultSet===========================================================================================Class.forName("org.sqlite.JDBC");//make this class available for driverConnection con=DriverManager.getConnection("jdbc:sqlite://home//Sanjai//Documents//univ.db");//connection to dbStatement stm=con.createStatement();ResultSet rs=stm.executeQuery("select * from dept");================================================================================================java.sql interfacesDriverManager :       Used to establish connection to DB from java program .       It will utilize JDBC driver using class.forName() anonymous object is given and that is used to establish connection and give connection object.       3 important methods in        DriverManager.getConnection(url)       DriverManager.getConnection(url,username,password)       DriverManager.getConnection(url,properties)       Connection :   Methods -      createStatement()      commit()      close() - releasing the resources      setAutoCommit() - if it is set to true then when ever dml operations are       done automatically it is commited.Statement : Types :     1.Statement     2.PreparedStatement     3.CallableStatement -> used for invoking stored procedures  PreparedStatement - used to get runtime input and execute the query [ -  con.preparedStatement("select * from students where deptno=?");   -  stmsetInt(1,dno); 1 is ? no (dno variable name)   - stm.executeQuery()--- for execution of preparedstatement ]  Method :    executeQuery() - to fetch and store in ResultSet, select    executeUpdate() - to insert , delete operation , update [ for DML queries ] ResultSet :    Methods     getint(__any__)- in __any__ it can be index or column|field name     getString()- should pass column name.Hibernate : Hibernate is a framework that helps you store and retrieve data from a database using objects in your Java programs, without you having  to write a lot of complex SQL code.    Object-Relational Mapping (ORM): This is the core magic. Hibernate maps your Java objects directly to tables in your database. So, a Book object in Java can be stored as a row in a Books table in the database, and vice versa. You work with objects, not raw database tables.The four main components are: * Configuration: This is like the blueprint for your application. It holds all the settings, like which database you're using (in your case, MySQL), the connection details, and where to find your object-to-table mapping files. * SessionFactory: Once your application has a Configuration, it uses it to build a SessionFactory. This is a big, expensive object to create, so you typically only have one per application. Think of it as a factory that's ready to create database connections on demand.immutable factory for creating Session objects. * Session: When you want to actually talk to the database—to save a new user, for example—you get a Session object from the SessionFactory. A Session is a lightweight object that represents a single conversation between your application and the database. * Transaction: Manages atomic operations, ensuring data consistency.Persistence Context :A cache of managed entities within a Session.Tracks changes to entities and synchronizes them with the database during commitpom.xml - > PROJECT OBJECT MODELJPA - java persistence APIKey JPA Features :Annotations for mappingJPQL (Java Persistence Query Language)Entity relationshipsTransactionsLifecycle callbacks-------------------------------------------------------------------------------------------------------hibernate.cfg.xml| Field      | Example         | Notes               || ---------- | --------------- | ------------------- || groupId    | `com.sanjai`    | Your namespace      || artifactId | `employee-crud` | Project/module name || version    | `1.0-SNAPSHOT`  | During development  || version    | `1.0.0`         | Final release       || Object State | Description                         | Example                 || ------------ | ----------------------------------- | ----------------------- || Transient    | Just created, not in DB             | `new Customer(...)`     || Persistent   | Saved via `session.save()`          | Tracked by Hibernate    || Detached     | Session closed, object still exists | After `session.close()` | Steps of Main file :| Step | Description                || ---- | -------------------------- || 1    | Load Hibernate config file || 2    | Create a session           || 3    | Begin transaction          || 4    | Create a new customer      || 5    | Save customer to DB        || 6    | Commit the transaction     || 7    | Close session and factory  |------------------------crudcashing part 1st level-------------------------for reading single object by its ID -> session.get() , session.load()where , group by, order by , having, 